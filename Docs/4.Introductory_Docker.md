# Comprehensive Guide to Docker

Docker is a platform that enables developers to package applications and their dependencies into containers. Containers are lightweight, portable, and ensure consistency across different environments.

## What is Docker?

Docker uses OS-level virtualization to deliver software in packages called containers. Containers are isolated from each other and include everything needed to run an application: code, runtime, libraries, and system tools.

## Why Use Docker?

- **Consistency:** Ensures your app runs the same everywhere.
- **Isolation:** Each container runs independently.
- **Portability:** Containers can run on any system with Docker installed.
- **Efficiency:** Containers are lightweight and use fewer resources than virtual machines.

## Installing Docker

Visit [Docker's official installation page](https://docs.docker.com/get-docker/) and follow instructions for your operating system.

## Key Docker Concepts

- **Image:** A Docker image is a read-only template that contains the application code, libraries, dependencies, and configuration files required to run your application. Images are used to create containers and can be versioned, shared, and reused. You can build your own images or use pre-built images from Docker Hub.

- **Container:** A container is a running instance of a Docker image. It encapsulates the application and its environment, providing process isolation and resource control. Containers are lightweight, start quickly, and can be stopped, started, or deleted without affecting the underlying image.

- **Dockerfile:** A Dockerfile is a plain text file that contains a set of instructions for building a Docker image. These instructions specify the base image, environment variables, files to copy, commands to run, and other configuration steps. Docker reads the Dockerfile to automate the image creation process.

- **Docker Hub:** Docker Hub is a cloud-based registry service where you can find, share, and manage Docker images. It hosts official images for popular software, as well as community-contributed images. You can push your own images to Docker Hub to share them with others or pull images to use in your projects.

## Essential Docker Commands
### Images

- `docker pull <image>`  
    Downloads a Docker image from Docker Hub or another registry to your local machine. For example, `docker pull ubuntu` fetches the latest Ubuntu image.

- `docker images`  
    Lists all Docker images stored locally, showing repository, tag, image ID, creation date, and size. Useful for managing and identifying available images.

- `docker rmi <image>`  
    Removes a specified image from your local system. You can use the image name or ID. For example, `docker rmi ubuntu:latest` deletes the Ubuntu image with the "latest" tag.

### Containers

- `docker run <image>`  
    Creates and starts a new container from the specified image. You can add options like `-d` for detached mode or `-p` to map ports. Example: `docker run -it ubuntu bash` starts an interactive Ubuntu shell.

- `docker ps`  
    Displays a list of currently running containers, including their IDs, names, status, and port mappings. Helps monitor active containers.

- `docker ps -a`  
    Shows all containers, both running and stopped. Useful for reviewing container history and managing stopped containers.

- `docker stop <container>`  
    Gracefully stops a running container by sending a SIGTERM signal. Use the container name or ID, e.g., `docker stop my_container`.

- `docker rm <container>`  
    Deletes a stopped container from your system. You can remove multiple containers at once, e.g., `docker rm container1 container2`.

### Building Images

- `docker build -t <name> .`  
    Builds a Docker image from a Dockerfile in the current directory and tags it with the specified name. For example, `docker build -t my-app .` creates an image called "my-app".

### Executing Commands in Containers

- `docker exec -it <container> <command>`  
    Runs a command inside a running container interactively. Commonly used for debugging or accessing a shell, e.g., `docker exec -it my_container bash` opens a bash shell in "my_container".

## Example: Simple Docker Workflow

1. **Create a Dockerfile:**  
    The Dockerfile defines the environment for your Python application.  
    ```dockerfile
    FROM python:3.10
    WORKDIR /app
    COPY . /app
    RUN pip install -r requirements.txt
    CMD ["python", "app.py"]
    ```
    - `FROM python:3.10` specifies the base image.
    - `WORKDIR /app` sets the working directory inside the container.
    - `COPY . /app` copies your project files into the container.
    - `RUN pip install -r requirements.txt` installs dependencies.
    - `CMD ["python", "app.py"]` runs your application.

2. **Build the image:**  
    Use the following command in your project directory (where the Dockerfile is located) to build the image:
    ```bash
    docker build -t my-python-app .
    ```
    - `-t my-python-app` tags the image with a name for easy reference.
    - `.` tells Docker to use the current directory as the build context.

3. **Run the container:**  
    Start a container from your image and map port 5000 on your host to port 5000 in the container:
    ```bash
    docker run -d -p 5000:5000 my-python-app
    ```
    - `-d` runs the container in detached mode.
    - `-p 5000:5000` maps ports for external access.

4. **Verify the container is running:**  
    List running containers:
    ```bash
    docker ps
    ```
    You should see `my-python-app` in the list.

5. **Access your application:**  
    Open your browser and go to `http://localhost:5000` (or the port your app uses).

6. **Stop and remove the container:**  
    To stop the container:
    ```bash
    docker stop <container_id>
    ```
    To remove it:
    ```bash
    docker rm <container_id>
    ```

This workflow helps you package, build, and run your Python application in a consistent environment using Docker.



## Docker Compose

Docker Compose is a tool for defining and managing multi-container Docker applications. You describe your application's services, networks, and volumes in a single `docker-compose.yml` file, making it easy to orchestrate complex setups.

### Key Features

- **Service Definition:** Specify multiple services (e.g., web, database) and their configurations in one file.
- **Networking:** Automatically creates a network for your containers to communicate.
- **Volume Management:** Easily define persistent storage for your services.
- **Environment Variables:** Pass environment variables to containers for configuration.

### Example `docker-compose.yml`

```yaml
version: '3.8'
services:
    web:
        build: .
        ports:
            - "5000:5000"
        volumes:
            - .:/app
        environment:
            - FLASK_ENV=development
    db:
        image: postgres:13
        environment:
            POSTGRES_USER: user
            POSTGRES_PASSWORD: password
            POSTGRES_DB: mydb
        volumes:
            - db_data:/var/lib/postgresql/data

volumes:
    db_data:
```

### Common Commands

- `docker-compose up`  
        Builds, (re)creates, starts, and attaches to containers for all services defined in `docker-compose.yml`. Add `-d` for detached mode.

- `docker-compose down`  
        Stops and removes containers, networks, and volumes created by `up`.

- `docker-compose ps`  
        Lists containers managed by Compose.

- `docker-compose logs`  
        Shows logs from all services.

### Workflow Example

1. **Define services in `docker-compose.yml`.**
2. **Start all services:**  
     ```bash
     docker-compose up
     ```
3. **Stop and clean up:**  
     ```bash
     docker-compose down
     ```

Docker Compose simplifies running multi-container applications, making development and testing more efficient.


## Docker Hub and Local Registry
Docker Hub is the default public registry for Docker images. It allows you to search, share, and manage container images. You can find official images for popular software, contribute your own, and collaborate with others. Pushing an image to Docker Hub makes it accessible from anywhere:

```bash
docker login
docker tag my-app username/my-app:latest
docker push username/my-app:latest
```

For private or enterprise use, you may want to host your own registry. A local Docker registry lets you store and distribute images within your organization, improving security and control. You can run a registry container locally:

```bash
docker run -d -p 5000:5000 --name registry registry:2
```

Push images to your local registry:

```bash
docker tag my-app localhost:5000/my-app
docker push localhost:5000/my-app
```

And pull them on other machines:

```bash
docker pull localhost:5000/my-app
```

### Allowing Docker to Pull from an Insecure Local Registry

By default, Docker expects registries to use HTTPS. If your local registry is running without TLS (HTTP), you need to configure Docker to allow connections to an insecure registry.

On each Docker host, add your registry’s IP and port to the Docker daemon configuration. For example, if your registry is at `192.168.1.100:5000`:

**Linux (edit `/etc/docker/daemon.json`):**
```json
{
    "insecure-registries": ["192.168.1.100:5000"]
}
```
Restart Docker for changes to take effect:
```bash
sudo systemctl restart docker
```

**Windows/Mac:**  
Update the Docker Desktop settings under "Daemon" or "Docker Engine" with the same JSON snippet.

After configuration, you can push and pull images using your registry’s IP:
```bash
docker tag my-app 192.168.1.100:5000/my-app
docker push 192.168.1.100:5000/my-app
docker pull 192.168.1.100:5000/my-app
```

Local registries are useful for development, testing, and environments with restricted internet access. You can also configure authentication and access controls for added security.



## Useful Resources

- [Docker Documentation](https://docs.docker.com/)
- [Docker Hub](https://hub.docker.com/)
- [Docker Compose](https://docs.docker.com/compose/)


---

Docker streamlines development, testing, and deployment. Mastering its commands and concepts will help you build robust, scalable applications.


